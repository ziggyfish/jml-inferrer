\section{Categorizing Method Implementations for Formal Verification}
\label{section:overview}

To evaluate our tool’s accuracy and scope, we categorize method implementations based on their structural and behavioral roles. Real-world software systems often contain a diverse mix of computational, utility, and control-flow functions, which complicates analysis if treated uniformly. Categorization clarifies this heterogeneity, allowing us to measure the tool’s performance across distinct method types rather than aggregated averages.

By grouping methods into well-defined categories, we simplify evaluation and isolate where specification inference performs best. This enables more precise assessment of both inference accuracy and applicability across diverse programming patterns. Such organization also supports comparability with prior work and clarifies how different method types respond to weakest precondition (WP) and strongest postcondition (SP) reasoning.

Our tool performs static analysis to infer formal specifications by tracing control flow and propagating correctness conditions backward through code. The analysis automatically derives:
\begin{itemize}
    \item Preconditions describing valid input states, and
    \item Postconditions defining expected output properties.
\end{itemize}
These inferred contracts act as machine-checkable documentation, improving maintainability and enabling systematic evaluation of formal verification across method categories.

\section{Weakest Precondition}

The weakest precondition method, first introduced by Dijkstra~\cite{dijkstra_guarded_1975}, identifies the essential requirements that must be satisfied before executing a program to ensure a specified postcondition holds afterward. This method systematically analyzes the program from its conclusion to its initiation, offering a structured approach to reasoning about program correctness~\cite{dijkstra1976discipline}. It facilitates the derivation of input conditions that guarantee specific outcomes.

\subsection{Formalizing Starting Conditions in Weakest Precondition Analysis}
\label{subsec:wp-starting-conditions}

In weakest precondition analysis, the \emph{starting condition} refers to the minimal requirements on the program state that must hold before executing a statement $S$ to ensure a given postcondition $Q$ holds afterward. Formally, the weakest precondition is defined as:

\[
\text{WP}(S, Q) = \{\, \sigma \mid \forall \sigma'.\, (\sigma \xrightarrow{S} \sigma') \Rightarrow Q(\sigma') \,\}
\]

That is, all initial states $\sigma$ for which every possible outcome $\sigma'$ of executing $S$ satisfies $Q$.

For example, given the statement $x := x + 1$ and postcondition $Q = (x > 5)$, the weakest precondition is:

\[
\text{WP}(x := x + 1, x > 5) = x > 4
\]

This expresses that the input state must satisfy $x > 4$ to guarantee that $x > 5$ holds after execution.

In practice, weakest precondition reasoning proceeds backward through code: for a sequence $S_1; S_2$, we compute $\text{WP}(S_1; S_2, Q) = \text{WP}(S_1, \text{WP}(S_2, Q))$. This compositionality enables precise precondition inference from a desired outcome, supporting formal verification, test generation, and behavioral specification inference.


\subsection{Assignment Statements}
\label{sec:assignment-statements}
For assignment statements, the weakest precondition is determined by substituting every occurrence of the assigned variable in the postcondition with the corresponding right-hand side expression~\cite{dijkstra1976discipline}. However, this substitution must also ensure that the right-hand side expression is \emph{well-defined}. This means that any potential runtime errors—such as division by zero, null dereferences, or out-of-bounds array accesses—must be excluded.

Formally, for an assignment $x := e$ and postcondition $Q$, the weakest precondition is expressed as:
$$
\text{WP}(\, x := e, Q) = \text{def}(e) \land Q[x \leftarrow e] 
$$
where $\text{def}(e)$ \cite{morgan_programming_1990} represents the conditions under which the expression $e$ is well-defined (e.g., array indices are within bounds and divisors are non-zero). The conjunction ensures that both the expression $e$ is safe to evaluate and the postcondition $Q$ holds after the substitution.

For example, given $Q = (x + y > 10)$ and $x := y + 2$, we compute:
$$
\text{WP}(\, x := y + 2, Q) = ((y + 2) + y > 10) = (2y + 2 > 10)
$$

\subsection{Conditional Statements}
Conditionals require the postcondition to hold across all branches. For a conditional statement with condition $C$, true branch $S_1$, and false branch $S_2$, the weakest precondition is:
$$
\text{WP}(\text{if } C, Q) = (C \rightarrow \text{WP}(S_1, Q)) \land (\neg C \rightarrow \text{WP}(S_2, Q))
$$
Given the example:
\begin{verbatim}
if (x > 5)
  y := x + 1
else
  y := x - 1
\end{verbatim}
and $Q = (y > 6)$, we derive:
$$
\begin{aligned}
& (x > 5 \rightarrow \text{WP}(y := x + 1, y > 6)) \land \\
& (\neg(x > 5) \rightarrow \text{WP}(y := x - 1, y > 6))
\end{aligned}
$$

Computing the assignment preconditions:
$$
(x > 5 \rightarrow x + 1 > 6) \land (x \leq 5 \rightarrow x - 1 > 6)
$$

This can be simplified to:
$$
(x > 5 \rightarrow x > 5) \land (x \leq 5 \rightarrow x > 7)
$$

\subsection{Return Statements}

Since the weakest precondition (WP) calculus does not treat \texttt{return} as a primitive, we model it by assigning a distinguished variable \texttt{result} followed by a termination operation~\cite{morgan_programming_1990}. Thus, \texttt{return e} is modeled as \texttt{result := e}, and we derive its weakest precondition using the standard assignment rule (see Section~\ref{sec:assignment-statements}). Moreover, as the return statements are the final statements executed in the control flow, they serve as the starting point from which all WPs are calculated. The initial postcondition will be true, reflecting that we infer only \emph{normal behaviour} specifications. Exceptional behaviour, such as that arising from \texttt{throw} statements, lies outside the scope of these specifications and is instead treated as a violation of the contract.


\subsection{Throw Statements}

In contrast to \texttt{return}, the weakest precondition (WP) calculus does not provide a direct primitive for modeling \texttt{throw} statements. A \texttt{throw} disrupts the normal control flow by transferring execution to an exception handler, which lies outside the scope of the normal behaviour specifications considered in this work. Since we assume that exceptions are undesirable and client code should avoid triggering them, we model \texttt{throw} as an immediate violation of the specification. 

Formally, we equate the WP of a \texttt{throw} statement with \texttt{false}, reflecting that no subsequent program state can satisfy the intended contract once an exception is raised. This captures the intuition that a program containing a reachable \texttt{throw} is inconsistent with the assumption of exception-free normal execution. 

\paragraph{Example.}  
Consider a statement of the form:
\[
    \texttt{throw e;}
\]
For any postcondition \(Q\), the weakest precondition is given by:
\[
    WP(\texttt{throw e}, Q) = \texttt{false}.
\]
This means that the presence of a \texttt{throw} statement generates a weakest precondition that requires all clients to avoid execution paths leading to the exception. In other words, the weakest precondition enforces that program states must prevent the \texttt{throw} from being reached, as no postcondition \(Q\) can be guaranteed once an exception is raised.


\subsubsection{Summary of Weakest Preconditions}
By iteratively applying these transformations to each line of code in reverse order, the tool calculates the weakest precondition necessary for the overall postcondition to hold. This backward propagation serves as the foundation of the analysis and facilitates the inference of precise specifications for the function.


\section{Strongest Postconditions and Loop Inference}
\label{section:strongest-postconditions}

In complement to weakest precondition (WP) analysis, our study explores the inference of strongest postconditions (SP) to enrich formal specification generation. While WP propagates correctness constraints backward from a postcondition, SP computes the forward effects of program execution, starting from known initial conditions. This directionality offers distinct advantages in dynamic verification, symbolic execution, and abstract interpretation.

Inferring strongest postconditions is particularly valuable when input conditions are fully known or can be assumed from the program context. This technique allows precise modeling of the exact outcomes and state transitions induced by a sequence of statements, thus aiding in specification discovery, test generation, and formal verification. It also enables automatic derivation of postconditions from implementations—a common challenge when documentation is sparse or outdated.

Incorporating SP inference into our categorization framework further delineates method complexity, especially in the presence of loops, mutable state, or compound branching. SP-based analysis becomes essential for verifying cumulative behavior in these scenarios and for refining inferred contracts during program synthesis or test oracle generation.

\subsection{Formalizing Starting Conditions in Strongest Postcondition Analysis}
\label{subsec:sp-starting-conditions}

Strongest postcondition (SP) analysis begins from a known initial condition, typically a logical predicate over program variables. In our case, this initial condition may originate from the precondition specified by the developer using the Java Modeling Language (JML) or could be derived from the previous weakest precondition (WP) analysis. These JML annotations delineate the assumptions that must be satisfied upon method entry.

Given a program statement $S$ and a JML-specified precondition $P$, the strongest postcondition $\text{SP}(P, S)$ describes all possible program states that may result from executing $S$ starting in any state that satisfies $P$.

Formally:
\[
\text{SP}(S, P) = \{\, \sigma' \mid \exists \sigma.\, P(\sigma) \land \sigma \xrightarrow{S} \sigma' \,\}
\]

Here, $\sigma$ is an initial program state that satisfies the JML precondition $P$, and $\sigma'$ is the resulting state after executing $S$. The relation $\sigma \xrightarrow{S} \sigma'$ denotes that executing $S$ in state $\sigma$ produces state $\sigma'$.

In practice, JML preconditions act as the entry-point assumptions for strongest postcondition (SP) inference. They are carried through the analysis to record the conditions that must hold after each possible execution path.

For loops, this starting condition may either be a loop invariant (if one is provided) or the program state at the beginning of loop unrolling. During SP-based reasoning, the initial predicate 

P is updated across successive iterations, converging toward an approximation of the loop’s cumulative effect. This process corresponds to computing the least fixpoint of the loop semantics, as described in Section~\ref{section:strongest-postconditions}.


\subsection{Strongest Postcondition}

The strongest postcondition, denoted $\text{SP}(S, P)$ for precondition $P$ and statement $S$, represents the most precise description of the program state after executing $S$, assuming the state initially satisfies $P$~\cite{morgan_programming_1990, hoare1969axiomatic}. Unlike WP, which checks that a postcondition is guaranteed after execution, SP enumerates what \emph{actually holds} after execution from a given starting state.

When a method accepts parameters, each is renamed to preserve its initial value during strongest postcondition (SP) analysis. For example:

\[
\texttt{int foo(T x\_in)\{T x=x\_in; S; return x;\}}
\]
Here, \texttt{x\_in} records the parameter’s entry value, allowing assignments such as \texttt{x = x + 1} to be expressed as \texttt{x := x\_in + 1}. The return statement then yields \texttt{result := x\_in + 1}, making the transformation from input to output explicit.


\subsubsection{Assignment Statements}

For an assignment $x := e$, and a precondition $P$, the SP is obtained by existentially quantifying over the variable being assigned and expressing that it assumes the new value:

\[
\text{SP}(\, x := e, P) = \exists x_0.\, (P[x \leftarrow x_0] \land x = e[x \leftarrow x_0])
\]

\textbf{Example:} Let $P = (x > 5)$ and $x := x + 1$. Then:
\[
\text{SP}(\, x := x + 1, x > 5) = \exists x_0.\, (x_0 > 5 \land x = x_0 + 1)
\]
which simplifies to:
\[
x > 6
\]

\subsubsection{Conditional Statements}

For a conditional statement of the form:

\begin{verbatim}
if (C) then S1 else S2
\end{verbatim}

the strongest postcondition is defined as a disjunction over both branches:

\[
\text{SP}(\text{if } C \text{ then } S_1 \text{ else } S_2, P) = 
\text{SP}(S_1, P \land C) \lor \text{SP}(S_2, P \land \neg C)
\]

\subsubsection{Return Statements}

As in WP, return statements are translated to assignments to a special variable \texttt{result}. SP propagates forward from the assignment:

\begin{align*}
\text{SP}&(\, \texttt{return}\ e, P) 
  = \text{SP}(\, \texttt{result} := e, P) \notag \\
  &= \exists r_0.\, \big(P[\texttt{result} \leftarrow r_0] 
     \land \texttt{result} = e[\texttt{result} \leftarrow r_0] \big)
\end{align*}

\textbf{Example:} Let $P = (x > 0)$ and \texttt{return x + 1}. Then:
\[
\text{SP}(\texttt{return } x + 1, x > 0) = x > 0 \land \texttt{result} = x + 1
\]

\subsection{Loop Inference with Strongest Postconditions}
\label{section:loops-sp}

Loop inference poses a significant challenge in formal verification due to the need to reason about potentially unbounded iteration and the need for invariants. In the strongest postcondition (SP) analysis, the goal is to characterise the set of all possible states resulting from executing a loop, starting from a given precondition $P$.

To achieve this, we iteratively apply SP over the loop body until reaching a fixpoint that captures the cumulative effect of all iterations. This is formally expressed as:

\[
\text{SP}(\, \text{while } C \text{ do } S, P) = \mu X.\, \left(P \lor \text{SP}(S, X \land C)\right)
\]

where $\mu X$ represents the least fixpoint—a set of states closed under repeated application of the loop body $S$ while condition $C$ holds.

In practice, exact fixpoint computation is undecidable for general loops. Therefore, our tool employs heuristic techniques to infer loop behavior:

\begin{itemize}
    \item \textbf{Invariant Guessing:} Derived from syntactic patterns, such as monotonic counter updates.
    \item \textbf{Symbolic Unrolling:} Executes the loop body a bounded number of times to detect emergent patterns.
    \item \textbf{Widening Operators:} Used to generalize from partial traces and stabilize convergence.
\end{itemize}

\textbf{Example:}
\begin{verbatim}
int sum = 0;
for (int i = 0; i < n; i++) {
    sum += i;
}
\end{verbatim}

\paragraph{Deriving the postcondition}  
The tool analyzes the loop as follows:  
1. \textbf{Initial state:} \( \texttt{sum} = 0, i = 0 \).  
2. \textbf{Symbolic unrolling:} The loop body is executed symbolically for the first few iterations:  
   \[
   \begin{aligned}
   i = 0 &\Rightarrow \texttt{sum} = 0\\
   i = 1 &\Rightarrow \texttt{sum} = 0 + 0 = 0\\
   i = 2 &\Rightarrow \texttt{sum} = 0 + 1 = 1\\
   i = 3 &\Rightarrow \texttt{sum} = 1 + 2 = 3
   \end{aligned}
   \]  
   From this pattern, the tool infers an arithmetic accumulation.  
3. \textbf{Invariant generalization / widening:} Using the detected pattern, the loop invariant is approximated as  
   \[
   \texttt{sum} = \sum_{k=0}^{i-1} k
   \]  
   which, at loop termination (\(i = n\)), yields the postcondition:  
   \[
   \texttt{sum} = \sum_{i=0}^{n-1} i = \frac{n(n-1)}{2}.
   \]

\paragraph{Limitations of heuristics}  
If the heuristics fail to find a suitable loop invariant (e.g., for non-linear updates, complex branching, or data-dependent loops), the inferred postcondition may be weaker or overly conservative. In such cases:  

\begin{itemize}
    \item The inferred SP may only capture partial behavior, such as upper/lower bounds instead of exact values.  
    \item Final method specifications remain sound but less precise, meaning they guarantee correctness for a subset of normal behaviors but may not express the full effect.  
    \item In practice, this occurs rarely for loops with simple arithmetic or monotonic updates, but more often for loops manipulating complex data structures or with nested loops.
\end{itemize}

\paragraph{Impact of weaker specifications}  
Weaker postconditions do not invalidate the overall correctness of the tool; they still allow clients to reason about normal behaviour safely. However, overly conservative specifications may reduce the utility of inferred contracts for test generation or interface validation, potentially requiring manual refinement for critical methods. In general, having some methods with weaker specifications is acceptable, as most normal program behavior is still captured accurately.

\section{Shared Libraries and Weakest Preconditions}
Shared libraries are essential components in distributed systems as they provide reusable methods that standardize communication protocols, including network requests, data serialization, and inter-service messaging. By abstracting these complexities, shared libraries enhance consistency and minimize redundancy across the system. This section elucidates common categories of method implementations, with particular emphasis on weakest precondition analysis, utilizing Java examples.

Our goal is to systematically categorize these methods and infer their specifications. Weakest preconditions provide a formal mechanism for verifying that certain conditions must hold for a method's execution to satisfy its postcondition.

\label{section:methodImplementation}

\subsection{Accessors \& Mutators}
Accessors (getters) and mutators (setters) are methods utilized to encapsulate and access class properties. Despite their seemingly straightforward nature, frequent use of these methods can significantly impact testing metrics~\cite{fowler2004refactoring}.

\begin{listing}
\begin{lstlisting}[language=Java, caption={Example of Accessor and Mutator}]
public class User {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
\end{lstlisting}
\end{listing}

For accessors and mutators, the weakest precondition (WP) and strongest postcondition (SP) are relatively straightforward.

\begin{itemize}
    \item \textbf{Accessor (getter):} The WP is trivially \texttt{true}, as no state changes occur. The SP is that the returned value equals the current field value, i.e., \texttt{result = name}.
    \item \textbf{Mutator (setter):} The WP depends on input constraints specified by the specifications. For example, \texttt{name != null \&\& name.length() > 0} if non-empty input is required. The SP is that the field is updated: \texttt{this.name == name}.
\end{itemize}


\subsection{Control Flow Structures}
This category encompasses conditional logic and exception handling. These constructs introduce branches that are essential for evaluating test path coverage and mutation testing~\cite{ammann2016introduction}.

\begin{listing}
\begin{lstlisting}[language=Java, caption={Conditional Logic Example}]
public int calculateDiscount(int quantity) {
    if (quantity > 10) {
        return 20;
    } else {
        return 10;
    }
}
\end{lstlisting}
\end{listing}

For control flow structures, the weakest precondition (WP) determines the necessary conditions for correct branching, while the strongest postcondition (SP) describes the expected outcomes associated with each branch.

\begin{itemize}
    \item \textbf{Conditional Logic:}  
    - \textbf{WP:} Depends on the condition and desired postcondition. For the \texttt{if} statement above, the WP ensures that the postcondition holds after either branch:  
   \begin{align*}
WP(&\texttt{if (quantity > 10)} \\
  &\texttt{then result := 20 else result := 10}, Q) \\
&= ((quantity > 10) \Rightarrow WP(result := 20, Q)) \\
&\quad \wedge ((quantity \le 10) \Rightarrow WP(result := 10, Q))
\end{align*}
    - \textbf{SP:} Represents the actual outcome given a starting state. For example, if \texttt{quantity = 15}, \(\texttt{SP} = (result = 20)\); if \texttt{quantity = 5}, \(\texttt{SP} = (result = 10)\).
\end{itemize}

\subsection{Factory \& Delegate Patterns}
Factory methods encapsulate object creation, while delegate methods forward calls. These patterns promote modularity and reuse; however, they necessitate precise testing due to their indirect behavior~\cite{bloch2008effective}.
\begin{listing}
\begin{lstlisting}[language=Java, caption={Factory and Delegate Methods}]
public static Connection createConnection() {
    return new DatabaseConnection();
}

public void save(User user) {
    database.save(user);
}
\end{lstlisting}
\end{listing}
For the factory and delegate patterns, the weakest precondition (WP) delineates the necessary conditions for object creation or method forwarding. Conversely, the strongest postcondition (SP) characterizes the expected outcome of the method's execution.

\begin{itemize}
    \item \textbf{Factory Method:} The WP for a factory method ensures that the required parameters are provided, if any. For example, \texttt{createConnection()} requires no parameters, so the WP is trivially true. The SP is the object created, in this case, a \texttt{DatabaseConnection}.
    \item \textbf{Delegate Method:} The WP for a delegate method ensures the input is valid (e.g., \texttt{user != null} for the \texttt{save} method). The SP is the result of forwarding the call to the delegate, in this case, a \texttt{save} action performed on the \texttt{user} object.
\end{itemize}

\subsection{Utility methods}
often defined as static, perform essential helper operations such as formatting and calculation. While their logic is straightforward, they are vital to the overall functionality~\cite{martin2008clean}.
\begin{listing}
\begin{lstlisting}[language=Java, caption={Utility and Intermediate Variable Methods}]
public static String capitalize(String input) {
    return input.substring(0, 1).toUpperCase() + input.substring(1);
}

public int doubleValue(int x) {
    int result = x * 2;
    return result;
}
\end{lstlisting}
\end{listing}
For utility methods, the weakest precondition (WP) establishes the necessary conditions that must be satisfied for the operation to be valid. In contrast, the strongest postcondition (SP) articulates the expected outcome of the method's execution.

\begin{itemize}
    \item \textbf{Utility Methods:} The WP for utility methods involves the input being valid for the operation (e.g., non-null string for a string manipulation method). The SP is the result of the operation, such as the transformation applied to the string.
    \item \textbf{Intermediate Variable Methods:} The WP ensures that the method’s input is valid (e.g., non-zero if the input is used as a divisor). The SP is the result of the computation, typically a value computed using the input. 
\end{itemize}

\subsection{Other Methods}
This category encompasses various logical frameworks and event-handling techniques. These techniques are often employed indirectly and require tailored testing strategies~\cite{gamma1994design}.
\begin{listing}
\begin{lstlisting}[language=Java, caption={Event Handler / Miscellaneous Method}]
public void handleClick(Event e) {
    System.out.println("Button clicked!");
}
\end{lstlisting}
\end{listing}

For methods such as event handlers and other miscellaneous methods, the weakest precondition (WP) typically involves verifying the validity of necessary parameters, such as the event object. The strongest postcondition (SP) generally specifies the expected side effects, which may include a printed message or a change in state.

\begin{itemize}
    \item \textbf{Other Methods:} The WP for these methods ensures that required inputs, like event data, are valid. The SP includes the expected side effects, such as logging, UI updates, or other actions performed by the method.
\end{itemize}

\subsection{State Modification}
State modification methods directly alter the internal state of objects. These methods differ from standard mutators by incorporating additional business logic, making them essential for behavioral testing~\cite{pressman2014software}.
\begin{listing}
\begin{lstlisting}[language=Java, caption={State-Changing Method}]
public void applyDiscount(double percentage) {
    if (percentage > 0) {
        this.price = this.price - (this.price * percentage);
    }
}
\end{lstlisting}
\end{listing}
