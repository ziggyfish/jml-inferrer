\section{Tool Architecture and Implementation}
\label{sec:approach}

This section provides a detailed description of our specification inference tool, including its architecture, key algorithms, and implementation decisions. Figure~\ref{fig:architecture} presents an overview of the tool's components and data flow.

\begin{figure}[t]
\centering
\resizebox{\textwidth}{!}{%
\begin{tikzpicture}[
    node distance=0.6cm and 0.8cm,
    component/.style={rectangle, draw, rounded corners, minimum width=2cm, minimum height=0.8cm, align=center, font=\footnotesize},
    subcomponent/.style={rectangle, draw, minimum width=1.6cm, minimum height=0.5cm, align=center, font=\scriptsize},
    data/.style={rectangle, draw, dashed, minimum width=1.4cm, minimum height=0.5cm, align=center, font=\scriptsize},
    arrow/.style={->, >=stealth, thick},
    phase/.style={rectangle, draw=gray, dashed, rounded corners, inner sep=0.2cm}
]

    % Input
    \node[data, fill=lightblue!50] (input) {Java\\Source};

    % Phase 1: Parsing
    \node[component, fill=lightyellow, right=1cm of input] (parser) {JavaParser};
    \node[data, right=0.6cm of parser] (ast) {AST};

    % Phase 2: Analysis
    \node[component, fill=lightgreen, right=0.6cm of ast] (analyzer) {Spec\\Analyzer};

    % Sub-components of analyzer (below)
    \node[subcomponent, below=0.4cm of analyzer, xshift=-1cm] (wp) {WP};
    \node[subcomponent, below=0.4cm of analyzer, xshift=1cm] (sp) {SP};
    \node[subcomponent, below=0.4cm of wp] (loop) {Loop Inv.};
    \node[subcomponent, below=0.4cm of sp] (simp) {Simplify};

    % Phase 3: Output
    \node[component, fill=lightpurple, right=1cm of analyzer] (formatter) {JML\\Format};
    \node[data, fill=lightblue!50, right=0.6cm of formatter] (output) {Annotated\\Source};

    % Arrows - main flow
    \draw[arrow] (input) -- (parser);
    \draw[arrow] (parser) -- (ast);
    \draw[arrow] (ast) -- (analyzer);
    \draw[arrow] (analyzer) -- (formatter);
    \draw[arrow] (formatter) -- (output);

    % Arrows - subcomponents
    \draw[arrow] (analyzer) -- (wp);
    \draw[arrow] (analyzer) -- (sp);
    \draw[arrow] (wp) -- (loop);
    \draw[arrow] (sp) -- (simp);
    \draw[arrow, <->] (wp) -- (sp);
    \draw[arrow] (loop) -- (wp);
    \draw[arrow] (simp) -- (sp);

    % Phase labels
    \node[above=0.1cm of parser, font=\scriptsize\bfseries] {Phase 1};
    \node[above=0.1cm of analyzer, font=\scriptsize\bfseries] {Phase 2};
    \node[above=0.1cm of formatter, font=\scriptsize\bfseries] {Phase 3};

\end{tikzpicture}%
}
\caption{Architecture of the specification inference tool. Phase 1 parses Java source into an AST. Phase 2 performs WP and SP analysis with loop invariant inference and expression simplification. Phase 3 formats inferred specifications as JML annotations.}
\label{fig:architecture}
\end{figure}

\subsection{Implementation Overview}

Our tool, \textbf{JML-Inferrer}, is implemented in Java 21 and comprises approximately 4,500 lines of code. The implementation uses JavaParser~\cite{javaparser} for AST manipulation. Table~\ref{tab:implementation} summarizes the key implementation characteristics.

\begin{table}[h]
\centering
\caption{Implementation characteristics}
\label{tab:implementation}
\begin{tabular}{ll}
\toprule
\textbf{Characteristic} & \textbf{Value} \\
\midrule
Implementation language & Java 21 \\
Lines of code & 4,521 \\
External dependencies & JavaParser 3.25, SLF4J/Logback \\
Supported Java version & 8--21 \\
Average analysis time & 88ms per file \\
Build system & Maven 3.9+ \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Tool Availability}

JML-Inferrer is released as open-source software under the Apache License 2.0. The tool is available via:

\begin{itemize}
    \item \textbf{GitHub}: Source code, documentation, and issue tracker
    \item \textbf{Maven Central}: Pre-built JAR artifacts for easy integration
    \item \textbf{Docker}: Containerized version for CI/CD pipelines
\end{itemize}

\subsubsection{Tool Usage}

The tool is distributed as an executable JAR and accepts a path to a Java codebase:

\begin{lstlisting}[language=bash, basicstyle=\ttfamily\small]
java -jar jml-inferrer-1.0.0-jar-with-dependencies.jar <path>
\end{lstlisting}

The tool recursively processes all \texttt{.java} files, adding annotations in-place. Output includes:
\begin{itemize}
    \item Annotated source files (modified in place)
    \item Metrics report (\texttt{jml-inference-metrics.json})
    \item Console summary with coverage statistics
\end{itemize}

For integration with build systems:
\begin{lstlisting}[language=bash, basicstyle=\ttfamily\small]
# Maven plugin usage
mvn jml-inferrer:infer

# Gradle task
./gradlew inferSpecifications
\end{lstlisting}

\subsubsection{Generated Annotation Types}

Table~\ref{tab:annotation-types} lists the JML-style annotations generated by JML-Inferrer. All annotations are defined in the \texttt{com.jml.inferrer.annotations} package and use runtime retention for accessibility.

\begin{table}[h]
\centering
\caption{Annotation types generated by JML-Inferrer}
\label{tab:annotation-types}
\small
\begin{tabular}{lll}
\toprule
\textbf{Annotation} & \textbf{Target} & \textbf{Description} \\
\midrule
\multicolumn{3}{l}{\textit{Contract Specifications}} \\
\texttt{@Requires} & Method & Precondition (repeatable) \\
\texttt{@Ensures} & Method & Postcondition (repeatable) \\
\texttt{@Signals} & Method & Exceptional postcondition \\
\texttt{@LoopInvariant} & Method & Loop invariant (repeatable) \\
\texttt{@Invariant} & Class & Class invariant (repeatable) \\
\texttt{@Assignable} & Method & Frame condition \\
\midrule
\multicolumn{3}{l}{\textit{Method Classification}} \\
\texttt{@Pure} & Method & No side effects, deterministic \\
\texttt{@Observer} & Method & Reads but doesn't modify state \\
\texttt{@Mutator} & Method & Modifies object state \\
\texttt{@ThreadSafe} & Method/Class & Thread-safe implementation \\
\midrule
\multicolumn{3}{l}{\textit{Nullability}} \\
\texttt{@Nullable} & Field/Param & May be null \\
\texttt{@NonNull} & Field/Param & Never null \\
\midrule
\multicolumn{3}{l}{\textit{Additional Properties}} \\
\texttt{@Immutable} & Field/Class & Immutable value \\
\texttt{@Complexity} & Method & Time/space complexity \\
\texttt{@MustCall} & Method & Required cleanup calls \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Specification Expression Syntax}

Specifications use JML-like syntax~\cite{leavens2006design, chalin2010jml} with the following constructs:

\begin{itemize}
    \item \texttt{\textbackslash result} -- The method's return value
    \item \texttt{\textbackslash old(expr)} -- Value of \texttt{expr} at method entry
    \item \texttt{\textbackslash nothing} -- Empty frame (no modifications)
    \item \texttt{this.field} -- Instance field reference
    \item \texttt{arr[*]} -- All array elements
    \item \texttt{(\textbackslash forall int k; range; prop)} -- Universal quantification
\end{itemize}

Example annotated method:
\begin{lstlisting}[language=Java, basicstyle=\ttfamily\small]
@Requires("operand != null")
@Ensures("this.value == \old(this.value) + operand.intValue()")
@Assignable("this.value")
@Mutator
@Complexity(time = "O(1)", space = "O(1)")
public void add(final Number operand) {
    this.value += operand.intValue();
}
\end{lstlisting}

\subsection{Worked Example: End-to-End Inference}
\label{subsec:worked-example}

To illustrate the specification inference process, we present a complete example showing how JML-Inferrer analyzes a method and derives its specification.

\subsubsection{Input Method}

Consider the following utility method that validates and returns an array element:

\begin{lstlisting}[language=Java, caption={Input method before specification inference}, label={lst:before}]
public static String getElement(String[] arr, int index) {
    if (arr == null) {
        throw new IllegalArgumentException("Array cannot be null");
    }
    if (index < 0 || index >= arr.length) {
        throw new IndexOutOfBoundsException("Invalid index");
    }
    return arr[index];
}
\end{lstlisting}

\subsubsection{WP Analysis (Backward Pass)}

Starting from the postcondition \texttt{true} at the return statement, WP analysis propagates backward:

\begin{enumerate}
    \item \textbf{Return statement}: $\text{WP}(\texttt{return arr[index]}, \texttt{true}) = \texttt{arr} \neq \texttt{null} \land 0 \leq \texttt{index} < \texttt{arr.length}$

    \item \textbf{Second if-statement}: The throw path generates $\neg(\texttt{index} < 0 \lor \texttt{index} \geq \texttt{arr.length})$, which simplifies to $0 \leq \texttt{index} < \texttt{arr.length}$

    \item \textbf{First if-statement}: The throw path generates $\texttt{arr} \neq \texttt{null}$
\end{enumerate}

\noindent\textbf{Inferred Preconditions}: \texttt{arr != null}, \texttt{index >= 0}, \texttt{index < arr.length}

\subsubsection{SP Analysis (Forward Pass)}

Using the inferred preconditions as the initial state, SP analysis computes:

\begin{enumerate}
    \item Given $P = (\texttt{arr} \neq \texttt{null} \land 0 \leq \texttt{index} < \texttt{arr.length})$
    \item After guards pass (no state change): $P' = P$
    \item At return: $\text{SP}(\texttt{return arr[index]}, P') = P' \land \texttt{\textbackslash result} = \texttt{arr[index]}$
\end{enumerate}

\noindent\textbf{Inferred Postcondition}: \texttt{\textbackslash result == arr[index]}

\subsubsection{Output: Annotated Method}

\begin{lstlisting}[language=Java, caption={Output method with inferred JML specifications}, label={lst:after}]
@Requires("arr != null")
@Requires("index >= 0")
@Requires("index < arr.length")
@Ensures("\\result == arr[index]")
@Assignable("\\nothing")
@Pure
@Complexity(time = "O(1)", space = "O(1)")
public static String getElement(String[] arr, int index) {
    if (arr == null) {
        throw new IllegalArgumentException("Array cannot be null");
    }
    if (index < 0 || index >= arr.length) {
        throw new IndexOutOfBoundsException("Invalid index");
    }
    return arr[index];
}
\end{lstlisting}

The tool also infers that the method is \texttt{@Pure} (no side effects) and has constant time complexity.

\subsection{Phase 1: Parsing and AST Construction}

The tool accepts Java source files or directories as input. Using JavaParser configured for Java 21 language features, each compilation unit is parsed into an Abstract Syntax Tree (AST). The parser is configured with:

\begin{itemize}
    \item Symbol resolution for type information
    \item Comment preservation for existing documentation
    \item Position tracking for error reporting
\end{itemize}

Methods are extracted from the AST and filtered based on the following criteria:
\begin{itemize}
    \item Non-abstract (must have a body)
    \item Not already annotated with JML specifications
    \item Not native or synthetic
\end{itemize}

\subsection{Phase 2: Specification Analysis}

\subsubsection{Heuristic-Based Pattern Matching}

The core analysis uses a visitor pattern over AST nodes with heuristic-based pattern matching rather than formal symbolic execution~\cite{king1976symbolic, cadar2008klee}. This pragmatic approach prioritizes scalability and handles common Java idioms effectively, trading some precision for practical applicability~\cite{calcagno2015infer}. Algorithm~\ref{alg:inference} presents the main inference procedure.

\begin{algorithm}[t]
\caption{Specification Inference via Pattern Matching}
\label{alg:inference}
\begin{algorithmic}[1]
\REQUIRE Method AST node $M$
\ENSURE Preconditions $Pre$, Postconditions $Post$, LoopInvariants $LI$
\STATE $Pre \gets \emptyset$; $Post \gets \emptyset$; $LI \gets \emptyset$
\STATE \COMMENT{Infer preconditions from early guards}
\FOR{each statement $S$ in $M$.body}
    \IF{$S$ is null check \texttt{if (p == null) throw/return}}
        \STATE $Pre \gets Pre \cup \{\texttt{p != null}\}$
    \ELSIF{$S$ is range check \texttt{if (p < 0 || p >= n) throw}}
        \STATE $Pre \gets Pre \cup \{\texttt{p >= 0}, \texttt{p < n}\}$
    \ENDIF
\ENDFOR
\STATE \COMMENT{Infer postconditions from return statements}
\FOR{each \texttt{return $e$} in $M$.body}
    \IF{$e$ is field access \texttt{this.f}}
        \STATE $Post \gets Post \cup \{\texttt{\textbackslash result == this.f}\}$
    \ELSIF{$e$ is new object \texttt{new T(...)}}
        \STATE $Post \gets Post \cup \{\texttt{\textbackslash result != null}\}$
    \ELSIF{$e$ involves \texttt{\textbackslash old} pattern}
        \STATE $Post \gets Post \cup \{$derive relationship$\}$
    \ENDIF
\ENDFOR
\STATE \COMMENT{Infer loop invariants}
\FOR{each loop $L$ in $M$.body}
    \STATE $LI \gets LI \cup \text{InferLoopInvariant}(L)$
\ENDFOR
\RETURN $(Pre, Post, LI)$
\end{algorithmic}
\end{algorithm}

\subsubsection{Loop Invariant Inference Heuristics}
\label{subsec:loop-heuristics}

Loop invariant inference is a key challenge in automated verification~\cite{cousot2011contract, wei2011inferring}. Our tool employs a combination of heuristics that have proven effective in practice:

\paragraph{Heuristic 1: Bound-Based Invariants.}
For loops with a clear iteration variable and bound:
\begin{lstlisting}[language=Java]
for (int i = 0; i < n; i++) { ... }
\end{lstlisting}
We infer: $0 \leq i \land i \leq n$.

\paragraph{Heuristic 2: Accumulator Patterns.}
For loops that accumulate values:
\begin{lstlisting}[language=Java]
int sum = 0;
for (int i = 0; i < n; i++) {
    sum += arr[i];
}
\end{lstlisting}
We track the accumulator variable and infer bounds based on symbolic unrolling.

\paragraph{Heuristic 3: Monotonicity Detection.}
We detect whether loop variables are monotonically increasing or decreasing by analyzing the update expression:
\begin{itemize}
    \item $i$\texttt{++} or $i$ \texttt{+= k} (for positive $k$): monotonically increasing
    \item $i$\texttt{--} or $i$ \texttt{-= k} (for positive $k$): monotonically decreasing
\end{itemize}

\paragraph{Heuristic 4: Symbolic Unrolling.}
For loops where pattern-based heuristics fail, we perform bounded symbolic unrolling (default: 3 iterations) to detect emergent patterns. If a consistent relationship is observed, it is generalized to an invariant candidate.

\paragraph{Fallback Behavior.}
When all heuristics fail, the tool produces a conservative postcondition that does not constrain the loop's effect. We record this as a ``weak specification'' for analysis (see Section~\ref{subsec:spec-strength}).

Table~\ref{tab:loop-heuristics} reports the success rate of each heuristic on our evaluation dataset.

\begin{table}[h]
\centering
\caption{Loop invariant inference success rates}
\label{tab:loop-heuristics}
\begin{tabular}{lrr}
\toprule
\textbf{Heuristic} & \textbf{Loops} & \textbf{Success Rate} \\
\midrule
Bound-based & 412 & 94.2\% \\
Accumulator pattern & 187 & 82.4\% \\
Monotonicity & 156 & 89.7\% \\
Symbolic unrolling & 89 & 61.8\% \\
\midrule
Overall & 844 & 85.3\% \\
Fallback (weak spec) & 124 & --- \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Method Call Handling}
\label{subsec:method-calls}

Method calls present a challenge because complete analysis would require interprocedural reasoning. Our tool handles method calls as follows:

\begin{enumerate}
    \item \textbf{Known specifications}: If the called method has an existing JML specification or has been previously analyzed, we use its contract.

    \item \textbf{Pure methods}: Methods annotated with \texttt{@Pure} or detected as side-effect-free are treated as uninterpreted functions in the specification.

    \item \textbf{Standard library methods}: We maintain a database of specifications for common Java standard library methods (e.g., \texttt{String.length()}, \texttt{Math.abs()}).

    \item \textbf{Unknown methods}: For methods without specifications, we make conservative assumptions:
    \begin{itemize}
        \item The method may throw any runtime exception
        \item The method may modify any accessible mutable state
        \item The return value is unconstrained
    \end{itemize}
\end{enumerate}

\subsubsection{Handling Complex Data Types}

\paragraph{Objects and Null Safety.}
Object dereferences generate definedness conditions. For \texttt{obj.field}, we add \texttt{obj != null} to the precondition. Chains like \texttt{a.b.c} generate conjunctions: \texttt{a != null \&\& a.b != null}.

\paragraph{Arrays.}
Array accesses \texttt{arr[i]} generate:
\[
\texttt{arr} \neq \texttt{null} \land 0 \leq i < \texttt{arr.length}
\]

\paragraph{Collections.}
For common collection operations (List, Set, Map), we use predefined specifications. For example, \texttt{list.get(i)} generates:
\[
\texttt{list} \neq \texttt{null} \land 0 \leq i < \texttt{list.size()}
\]

\subsection{Phase 3: Specification Formatting and Integration}

Inferred specifications are formatted as JML annotations~\cite{jml} and inserted as Javadoc comments:

\begin{lstlisting}[language=Java]
/**
 * @requires x >= 0;
 * @ensures \result == x * 2;
 */
public int doubleValue(int x) {
    return x * 2;
}
\end{lstlisting}

The formatter applies several transformations:
\begin{itemize}
    \item Expression simplification using Z3
    \item Constant folding and algebraic simplification
    \item Removal of trivially true conditions
    \item Formatting for readability (line wrapping, indentation)
\end{itemize}

\subsection{Expression Simplification}
\label{subsec:simplification}

Complex expressions arising from pattern analysis are simplified using algebraic rules:

\begin{enumerate}
    \item \textbf{Algebraic rules}: Standard simplifications such as $x + 0 = x$, $x \land \texttt{true} = x$, double negation elimination.

    \item \textbf{Range analysis}: Numeric constraints are combined where possible. For example, $(x > 5) \land (x > 3)$ simplifies to $(x > 5)$.

    \item \textbf{Constant folding}: Compile-time constant expressions are evaluated.
\end{enumerate}

\subsection{Metrics and Output}
\label{subsec:metrics}

The tool generates comprehensive metrics in JSON format (\texttt{jml-inference-metrics.json}) including:

\begin{itemize}
    \item \textbf{Timing metrics}: Total analysis time, per-file and per-class averages
    \item \textbf{Code metrics}: Files, classes, methods, lines of code analyzed
    \item \textbf{Annotation coverage}: Percentage of methods with each annotation type
    \item \textbf{Annotation distribution}: Count of each annotation type generated
    \item \textbf{Specification strength}: Distribution of weak/medium/strong specifications
    \item \textbf{Method classification}: Counts of Pure/Observer/Mutator methods
    \item \textbf{Complexity distribution}: O(1), O(n), O(n\textsuperscript{2}), etc.
\end{itemize}

Example console output:
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
=================================================
JML SPECIFICATION INFERENCE - METRICS REPORT
=================================================
[CODE METRICS]
  Total Files Analyzed: 11
  Total Methods: 312
[ANNOTATION COVERAGE]
  Methods with Annotations: 99.0% (309/312)
  Methods with Preconditions: 34.9% (109/312)
  Methods with Postconditions: 51.9% (162/312)
TOTAL ANNOTATIONS GENERATED: 3,140
=================================================
\end{lstlisting}

\subsection{Differences from Traditional WP/SP}

Our implementation diverges from textbook WP/SP in several pragmatic ways:

\begin{enumerate}
    \item \textbf{Exception-aware}: We treat \texttt{throw} statements as specification violations, generating preconditions that exclude exception-triggering paths.

    \item \textbf{Heuristic loop handling}: Rather than requiring user-provided loop invariants, we employ automated inference heuristics with fallback to conservative specifications.

    \item \textbf{JML output}: Specifications are formatted in JML syntax for compatibility with existing Java verification tools.

    \item \textbf{Incremental analysis}: Methods are analyzed independently, with results cached for reuse when analyzing callers.
\end{enumerate}

\subsection{Categorization of Method Types}
\label{subsec:categorization}

To systematically evaluate specification inference across diverse method implementations, we developed a categorization taxonomy. Our taxonomy builds on prior work on method stereotypes~\cite{dragan2006reverse} and extends it with categories relevant to specification inference effectiveness.

\subsubsection{Taxonomy Design Process}

The taxonomy was developed through an iterative process:
\begin{enumerate}
    \item Initial categories derived from literature review~\cite{dragan2006reverse, fowler2004refactoring}
    \item Refinement based on pilot analysis of 500 randomly sampled methods
    \item Inter-rater reliability assessment (Cohen's $\kappa = 0.87$)
\end{enumerate}

\subsubsection{Category Definitions}

\paragraph{Accessors \& Mutators.}
Methods that read or write object fields without additional logic. Getters have trivial preconditions; setters have preconditions based on input constraints.

\paragraph{Control Flow Structures.}
Methods with conditional branching (\texttt{if}, \texttt{switch}) or loops. These test WP propagation through multiple paths.

\paragraph{Factory \& Delegate Patterns.}
Object creation methods and forwarding methods. Preconditions involve parameter validation; postconditions describe the created/returned object.

\paragraph{Support \& Utility Methods.}
Static helper methods performing transformations or calculations. Often have complex preconditions involving input format/range requirements.

\paragraph{State Modification.}
Methods that modify object state with business logic beyond simple assignment. Preconditions may involve object state invariants.

\paragraph{Other Methods.}
Event handlers, callbacks, and methods with side effects not captured by other categories. These typically have weaker inferred specifications.

\subsubsection{Categorization Procedure}

Methods are automatically categorized using the following rules:
\begin{enumerate}
    \item \textbf{Accessors}: Single return statement returning a field
    \item \textbf{Mutators}: Single assignment to a field from a parameter
    \item \textbf{Factory}: Returns \texttt{new} expression or calls constructor
    \item \textbf{Delegate}: Body consists of single method call on a field
    \item \textbf{Control Flow}: Contains \texttt{if}, \texttt{switch}, or loops
    \item \textbf{Utility}: Static method performing computation
    \item \textbf{State Modification}: Modifies fields with additional logic
    \item \textbf{Other}: Does not match above patterns
\end{enumerate}

When multiple patterns match, the most specific category is selected (e.g., a factory method with conditionals is categorized as Factory).
